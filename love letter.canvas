{
	"nodes":[
		{"id":"e7487be013bd380c","type":"text","text":" # hints\n\n*At the end... all that matters is love.*\n\n```bash\n[*] '/home/loveletter/loveletter'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n No PIE :) and 32 bit ","x":-840,"y":-401,"width":640,"height":641,"color":"5"},
		{"id":"5f2af846d7b1989b","type":"text","text":"# gdb \n\n```\nb *0x08048857 - take from the stack prolog's size\nb *0x0804887E - first memcpy\nb *0x08048883 - after first\nb *0x080488C6 - after second\nb *0x0804890A - after third\nb *0x0804891C - after all memcpy\nb *0x08048691 - malfunction code in protect\n0x0804A080 - i's bss\n0x0804A0A0 - loveletter location\n```","x":-840,"y":360,"width":640,"height":620},
		{"id":"a3e4b7d6fe88a3ed","type":"text","text":"# write\n\nwe can to anywhere above `loveletter` including `loveletter`","x":320,"y":2054,"width":560,"height":346},
		{"id":"8e8f982febb5fe1d","type":"text","text":"# idea\n\n* overwrite `prolog_size` to be -12 (`edx 0xfffffff4 -12`)\n* Then `s` should be `cat flag`\nwe can't put a negative value inside any of the sizes","x":-560,"y":2340,"width":740,"height":320,"color":"1"},
		{"id":"72749be28826815d","type":"text","text":"# overwrite prolog\n* change `prolog_size`  and `epilog_size` to zero\n* put inside `s` *cat flag* (I hope it will run at the right privilege level)\n","x":470,"y":2594,"width":510,"height":406,"color":"4"},
		{"id":"817fc0f2a425871d","type":"text","text":"# implementation\n\npopulate `prolog_size` and `epilog_size`\nI can populate `prolog_size` using `A*252 [ AA` \nwe have a null in the 256 byte so `A*253 [ A`\nI could not use a character after `[` because it will be copied to `prolog_size`.\n\n`A*253 [` should work\n\n```\nsh: 1: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA♥: File name too long\n```\nyay let's add the cat flag\n```\ncat flag AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[\n```\n\nworked remotely :)","x":432,"y":3160,"width":728,"height":1120},
		{"id":"4e1cff6d85bac8ca","type":"text","text":"# writeups\npeople did the same idea and used `/bin/sh` I misread the `\\` to be `/` :().\n### using memcpy\nmoreover people used the `memcpy` to copy the last byte to `prolog_size` and gave it `\\x01` . Then used the shell change e to \nexec or to e=dummy cat flag. \n","x":-200,"y":3160,"width":520,"height":600,"color":"2"},
		{"id":"595f75fd2e53ebe2","type":"text","text":"# understanding the challenge\n\nthe challenge is on port 9034.\nThe program reads a name and print the following\n```\nname\nI love name very much!\n♥ My lover's name is : ♥ Whatever happens, I'll protect her...\n♥ Impress her upon my memory...\n♥ Her name echos in my mind...\n```\nif you give it a special character like `]` it prints garbage....\n\n# main\n *♥ My lover's name is :* \n* `fgets(s, 256, stdin)` (`s` is 256 bytes)\n* if the last char of s is `0xa` change it to `null` (if we inputted 255 bytes)\n *♥ Whatever happens, I'll protect her...*\n* protect(s) - if s contains ```#&;`'\"|*?~<>^()[]{}$\\,``` protect will trash s :)\n*♥ Impress her upon my memory...*\n* copy to `loveletter` `prolog`, `s` `epilog` . the index is zero on `gdb`, maybe the `bss` is zero\n* system(`loveletter`)  -> system(`echo I love [payload] very much!`) \n\n# abilities\n* I can overflow the bss segment ;) `loveletter` size is 256 bytes, and prolog and epilog sizes are 12, 11. so I can overflow 23 bytes in bss... \n* maybe I can use `protect` to leak addresses or something...\n\n# protect\n\nprotect if encounter an invalid char will substitute the char (1 byte) to a heart character with null (4 bytes) and save the suffix after the invalid char above the current `s` on the stack.\n\n* `strcpy(suffix, s + i + 1)` (`invalid_chars[23]`)\n* `s[i] = ♥\\0` \n![[Pasted image 20231125143852.png]]\n* `memcpy(s+len(s), suffix, len(suffix))`\n![[Pasted image 20231125143818.png]]\nafter `memcpy`\n![[Pasted image 20231125144136.png]]\nthis `memcpy` harms `s` because it doesn't add a null at the end of the new `s`.\nmoreover the `suffix` overwrites 3 bytes from main's stack.\n\nthe next time we will take the suffix we will include stack values\n![[Pasted image 20231125150955.png]]\n# ability\nusing protect we can overwrite main's stack and leak addresses...","x":460,"y":-280,"width":1080,"height":2260}
	],
	"edges":[
		{"id":"16d88384ddad71cd","fromNode":"595f75fd2e53ebe2","fromSide":"bottom","toNode":"a3e4b7d6fe88a3ed","toSide":"top"},
		{"id":"dabd2e14a7c3167c","fromNode":"a3e4b7d6fe88a3ed","fromSide":"bottom","toNode":"72749be28826815d","toSide":"top"}
	]
}